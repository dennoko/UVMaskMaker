// UVMaskMakerWindow.cs
// Unity 2022.3+ Editor tool to generate black/white UV mask images based on selected UV islands.
// Author: Generated by GitHub Copilot for the user's project.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.Pool;

namespace Dennoko.UVTools
{
    /// <summary>
    /// EditorWindow that lets you select a MeshRenderer/SkinnedMeshRenderer from the scene,
    /// detect UV seams (outer UV borders), select UV islands with a hotkey+click,
    /// preview the mask, and export a black/white PNG.
    /// </summary>
    public class UVMaskMakerWindow : EditorWindow
    {
        // Persisted EditorPrefs keys
        private const string Pref_LastSaveDir = "Dennoko.UVTools.UVMaskMaker.LastSaveDir";
    private const string Pref_TextureSize = "Dennoko.UVTools.UVMaskMaker.TextureSize";
    private const string Pref_Hotkey = "Dennoko.UVTools.UVMaskMaker.Hotkey"; // legacy
    private const string Pref_AddHotkey = "Dennoko.UVTools.UVMaskMaker.AddHotkey";
    private const string Pref_RemoveHotkey = "Dennoko.UVTools.UVMaskMaker.RemoveHotkey";
        private const string Pref_PixelMargin = "Dennoko.UVTools.UVMaskMaker.PixelMargin";
        private const string Pref_ShowSelectedScene = "Dennoko.UVTools.UVMaskMaker.ShowSelectedScene";
        private const string Pref_SelectedSceneColor = "Dennoko.UVTools.UVMaskMaker.SelectedSceneColor";
        private const string Pref_PreviewFillSelectedColor = "Dennoko.UVTools.UVMaskMaker.PreviewFillSelectedColor";
    private const string Pref_OverlayOnTop = "Dennoko.UVTools.UVMaskMaker.OverlayOnTop";
    private const string Pref_OverlayDepthOffset = "Dennoko.UVTools.UVMaskMaker.OverlayDepthOffset";
    private const string Pref_OverlaySeamThickness = "Dennoko.UVTools.UVMaskMaker.OverlaySeamThickness";
    private const string Pref_UseBakedMesh = "Dennoko.UVTools.UVMaskMaker.UseBakedMesh";
    private const string Pref_PreviewOverlayBaseTex = "Dennoko.UVTools.UVMaskMaker.PreviewOverlayBaseTex";
    private const string Pref_PreviewOverlayAlpha = "Dennoko.UVTools.UVMaskMaker.PreviewOverlayAlpha";
        private const string Pref_ColorOptionsFoldout = "Dennoko.UVTools.UVMaskMaker.ColorOptionsFoldout";
    private const string Pref_ModeToggleHotkey = "Dennoko.UVTools.UVMaskMaker.ModeToggleHotkey";
    private const string Pref_SeamColor = "Dennoko.UVTools.UVMaskMaker.SeamColor";
    private const string Pref_AdvancedOptionsFoldout = "Dennoko.UVTools.UVMaskMaker.AdvancedOptionsFoldout";
    private const string Pref_ChannelWriteFoldout = "Dennoko.UVTools.UVMaskMaker.ChannelWriteFoldout";
    private const string Pref_DisableAA = "Dennoko.UVTools.UVMaskMaker.DisableAA";
    private const string Pref_BackfaceCull = "Dennoko.UVTools.UVMaskMaker.BackfaceCull";
    private const string Pref_UVChannel = "Dennoko.UVTools.UVMaskMaker.UVChannel";
    private const string Pref_ShowIslandPreview = "Dennoko.UVTools.UVMaskMaker.ShowIslandPreview";
    private const string Pref_InvertMask = "Dennoko.UVTools.UVMaskMaker.InvertMask";
    // Channel-wise export prefs
    private const string Pref_ChannelWrite = "Dennoko.UVTools.UVMaskMaker.ChannelWrite";
    private const string Pref_ChannelWrite_R = "Dennoko.UVTools.UVMaskMaker.ChannelWrite.R";
    private const string Pref_ChannelWrite_G = "Dennoko.UVTools.UVMaskMaker.ChannelWrite.G";
    private const string Pref_ChannelWrite_B = "Dennoko.UVTools.UVMaskMaker.ChannelWrite.B";
    private const string Pref_ChannelWrite_A = "Dennoko.UVTools.UVMaskMaker.ChannelWrite.A";
    private const string Pref_BasePNGAssetPath = "Dennoko.UVTools.UVMaskMaker.BasePNG";
    private const string Pref_BaseVCMeshAssetPath = "Dennoko.UVTools.UVMaskMaker.BaseVCMesh";

    // Log file paths
    private static string LogDir => Path.Combine(Application.dataPath, "../Logs/UVMaskMaker");
    private static string LogPath => Path.Combine(LogDir, "UVMaskMaker.log");

    // Target selection and mesh refs
    private GameObject _targetGO;
    private Renderer _targetRenderer;
    private Mesh _targetMesh;
    private Transform _targetTransform;

    // UI state
    private Vector2 _scrollPos;
    private int _textureSize = 512;
    private string _outputDir = "Assets/GeneratedMasks";
    private string _fileName = "uv_mask";
    private int _pixelMargin = 2;
    private bool _addMode = true;
    private KeyCode _modeToggleHotkey = KeyCode.R;

    // Depth offset throttling (meters)
    private float _pendingOverlayDepthOffset = 0f;
    private double _nextDepthCommitTime = 0;
    private const double DepthCommitIntervalSec = 0.08; // seconds
    private bool _showSelectedInScene = true; // always true now
    private Color _selectedSceneColor = new Color(0f, 1f, 1f, 1f); // cyan (Selected Islands)
    private Color _seamColor = new Color(1f, 0.15f, 0.15f, 1f);
    private Color _previewFillSelectedColor = Color.black;
    private bool _overlayOnTop = false; // draw overlays on top (zTest Always)
    private float _overlayDepthOffset = 0.0f; // push overlay along normals in meters
    private float _overlaySeamThickness = 2.5f; // pixels
    private bool _disableAA = true; // アンチエイリアス無効（高速）
    private bool _backfaceCull = true; // バックフェース抑制（選択表示）
    private bool _showColorOptionsFoldout = false;
    private bool _showAdvancedOptionsFoldout = false;
    private bool _showChannelWriteFoldout = false;
    private int _uvChannel = 0;
    private bool _showIslandPreview = false;
    private bool _invertMask = false; // 出力マスクの反転（Union結果へ適用）
    // Channel-wise export fields
    private bool _channelWrite = false;
    private Texture2D _basePNG;
    private Mesh _baseVCMesh; // for vertex color baking base
    private bool _cwR = true, _cwG = false, _cwB = false, _cwA = false;

        // Preview label-map cache
        private int[] _labelMap;
        private int _labelMapSize = 0;
        private bool _labelMapDirty = true;

        // Overlay geometry cache
    private Matrix4x4 _lastLocalToWorld;
    private bool _overlayCacheValid = false; // validity of world-space cache (positions/normals)
    private Vector3[] _worldPosBase;   // world-space vertex positions at offset=0
    private Vector3[] _worldNormal;    // world-space vertex normals (normalized)

        // Computed data
        private UVAnalysis _analysis; // stores islands, seams, etc
        private HashSet<int> _selectedIslands = new HashSet<int>();
        private Texture2D _previewTex;
        private bool _previewDirty = true;
    private Texture2D _previewOverlayTex; // semi-transparent overlay derived from mask
    private bool _previewOverlayBaseTex = false; // show base texture under mask overlay
    private float _previewOverlayAlpha = 0.6f; // overlay alpha when drawing over base texture
    // ホットキーの二重トグル防止用（デバウンス）
    private double _lastHotkeyToggleTime = 0;

        // Picking helpers
        private MeshCollider _tempCollider;
        private GameObject _tempColliderGO;

    // Baked mesh (for SkinnedMeshRenderer alignment)
    private Mesh _bakedMesh;
    private bool _useBakedMesh = false; // when true and baked exists, overlays/picking use baked vertices

        // Colors
    private static readonly Color SeamColor = new Color(1f, 0.15f, 0.15f, 1f);
    private static readonly Color IslandFillSelected = Color.black;
        private static readonly Color IslandFillUnselected = Color.white;
        private static readonly Color UVFrame = new Color(0.25f, 0.25f, 0.25f, 1);

        [MenuItem("Tools/UV Mask Maker")] 
        public static void ShowWindow()
        {
            var wnd = GetWindow<UVMaskMakerWindow>();
            wnd.titleContent = new GUIContent("UVマスクメーカー");
            wnd.minSize = new Vector2(480, 520);
            wnd.Show();
        }

        private void OnEnable()
        {
            try
            {
                Directory.CreateDirectory(LogDir);
                Log($"[OnEnable] Window opened at {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            }
            catch { /* ignore */ }

            _textureSize = EditorPrefs.GetInt(Pref_TextureSize, 512);
            _outputDir = EditorPrefs.GetString(Pref_LastSaveDir, _outputDir);
            // Mode toggle hotkey
            _modeToggleHotkey = (KeyCode)EditorPrefs.GetInt(Pref_ModeToggleHotkey, (int)KeyCode.R);
            _pixelMargin = EditorPrefs.GetInt(Pref_PixelMargin, 2);
            _showSelectedInScene = true; // always enabled
            var colorHex = EditorPrefs.GetString(Pref_SelectedSceneColor, ColorUtility.ToHtmlStringRGBA(_selectedSceneColor));
            if (ColorUtility.TryParseHtmlString("#" + colorHex, out var parsedCol)) _selectedSceneColor = parsedCol;
            var seamHex = EditorPrefs.GetString(Pref_SeamColor, ColorUtility.ToHtmlStringRGBA(_seamColor));
            if (ColorUtility.TryParseHtmlString("#" + seamHex, out var parsedSeam)) _seamColor = parsedSeam;
            var pfillHex = EditorPrefs.GetString(Pref_PreviewFillSelectedColor, ColorUtility.ToHtmlStringRGBA(_previewFillSelectedColor));
            if (ColorUtility.TryParseHtmlString("#" + pfillHex, out var parsedFill)) _previewFillSelectedColor = parsedFill;
            _overlayOnTop = EditorPrefs.GetBool(Pref_OverlayOnTop, false);
            _overlayDepthOffset = EditorPrefs.GetFloat(Pref_OverlayDepthOffset, 0f);
            _overlaySeamThickness = EditorPrefs.GetFloat(Pref_OverlaySeamThickness, 2.5f);
            _useBakedMesh = EditorPrefs.GetBool(Pref_UseBakedMesh, false);
            _previewOverlayBaseTex = EditorPrefs.GetBool(Pref_PreviewOverlayBaseTex, false);
            _previewOverlayAlpha = EditorPrefs.GetFloat(Pref_PreviewOverlayAlpha, 0.6f);
            _showColorOptionsFoldout = EditorPrefs.GetBool(Pref_ColorOptionsFoldout, false);
            _showAdvancedOptionsFoldout = EditorPrefs.GetBool(Pref_AdvancedOptionsFoldout, false);
            _showChannelWriteFoldout = EditorPrefs.GetBool(Pref_ChannelWriteFoldout, false);
            _pendingOverlayDepthOffset = _overlayDepthOffset;
            _disableAA = EditorPrefs.GetBool(Pref_DisableAA, true);
            _backfaceCull = EditorPrefs.GetBool(Pref_BackfaceCull, true);
            _uvChannel = EditorPrefs.GetInt(Pref_UVChannel, 0);
            _showIslandPreview = EditorPrefs.GetBool(Pref_ShowIslandPreview, false);
            _invertMask = EditorPrefs.GetBool(Pref_InvertMask, false);

            // Channel-wise prefs
            _channelWrite = EditorPrefs.GetBool(Pref_ChannelWrite, false);
            _cwR = EditorPrefs.GetBool(Pref_ChannelWrite_R, true);
            _cwG = EditorPrefs.GetBool(Pref_ChannelWrite_G, false);
            _cwB = EditorPrefs.GetBool(Pref_ChannelWrite_B, false);
            _cwA = EditorPrefs.GetBool(Pref_ChannelWrite_A, false);
            var basePngPath = EditorPrefs.GetString(Pref_BasePNGAssetPath, string.Empty);
            if (!string.IsNullOrEmpty(basePngPath)) _basePNG = AssetDatabase.LoadAssetAtPath<Texture2D>(basePngPath);
            var baseVCPath = EditorPrefs.GetString(Pref_BaseVCMeshAssetPath, string.Empty);
            if (!string.IsNullOrEmpty(baseVCPath)) _baseVCMesh = AssetDatabase.LoadAssetAtPath<Mesh>(baseVCPath);

            SceneView.duringSceneGui += OnSceneGUI;
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
            EditorSceneManager.sceneSaving += OnSceneSaving;
        }

        private void OnDisable()
        {
            SceneView.duringSceneGui -= OnSceneGUI;
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
            EditorSceneManager.sceneSaving -= OnSceneSaving;
            CleanupTempCollider();
            if (_bakedMesh != null)
            {
                try { DestroyImmediate(_bakedMesh); } catch { }
                _bakedMesh = null;
            }
            if (_previewTex != null)
            {
                DestroyImmediate(_previewTex);
                _previewTex = null;
            }
            if (_previewOverlayTex != null)
            {
                DestroyImmediate(_previewOverlayTex);
                _previewOverlayTex = null;
            }
            Log("[OnDisable] Window closed");
        }

        private void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            // Toggle hotkey model: no per-frame held state to reset
        }

        private void OnSceneSaving(UnityEngine.SceneManagement.Scene scene, string path)
        {
            // Make sure we don't leave temp objects
            CleanupTempCollider();
        }

        private void OnGUI()
        {
            // ウィンドウ側でもホットキーを受け付ける（テキスト入力中は無効）
            var eWindow = Event.current;
            if (eWindow != null && eWindow.type == EventType.KeyDown && eWindow.keyCode == _modeToggleHotkey && !EditorGUIUtility.editingTextField)
            {
                ToggleAddRemoveMode(null);
                eWindow.Use();
            }
            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("対象モデル", EditorStyles.boldLabel);

            // Drag-and-drop area
            var dropRect = GUILayoutUtility.GetRect(0, 40, GUILayout.ExpandWidth(true));
            GUI.Box(dropRect, "MeshRenderer/SkinnedMeshRenderer を含む GameObject をここへドラッグ", EditorStyles.helpBox);
            HandleDragAndDrop(dropRect);

            // Object field selection + Clear button
            using (new EditorGUILayout.HorizontalScope())
            {
                var newObj = EditorGUILayout.ObjectField(new GUIContent("Object", "対象のGameObject（MeshRenderer または SkinnedMeshRenderer を含む）を指定します。"), _targetGO, typeof(GameObject), true) as GameObject;
                if (newObj != _targetGO)
                {
                    SetTarget(newObj);
                }
                GUI.enabled = _targetGO != null;
                if (GUILayout.Button(new GUIContent("Clear", "現在の対象オブジェクトの設定をクリアします。"), GUILayout.Width(60)))
                {
                    SetTarget(null);
                }
                GUI.enabled = true;
            }

            // Bake controls for SkinnedMeshRenderer
            if (_targetRenderer is SkinnedMeshRenderer)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    bool useBaked = EditorGUILayout.ToggleLeft(new GUIContent("Use Baked Mesh", "ベイク済みメッシュを使用して、表示・ピッキングの整合を高めます。ポーズ固定の確認に便利です。"), _useBakedMesh, GUILayout.Width(140));
                    if (useBaked != _useBakedMesh)
                    {
                        _useBakedMesh = useBaked;
                        EditorPrefs.SetBool(Pref_UseBakedMesh, _useBakedMesh);
                        _overlayCacheValid = false;
                        if (_tempCollider != null)
                        {
                            _tempCollider.sharedMesh = (_useBakedMesh && _bakedMesh != null) ? _bakedMesh : _targetMesh;
                        }
                        SceneView.RepaintAll();
                    }
                }
            }

            EditorGUILayout.Space();
            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.LabelField(new GUIContent("モード", "クリック時の基本動作。Addは島を追加、Removeは削除。"), GUILayout.Width(50));
                int toolbar = GUILayout.Toolbar(_addMode ? 0 : 1, new[] { new GUIContent("Add", "クリックしたUVアイランドを選択に追加します。"), new GUIContent("Remove", "クリックしたUVアイランドを選択から除外します。") });
                _addMode = toolbar == 0;
                GUILayout.FlexibleSpace();
                EditorGUILayout.LabelField(new GUIContent("トグルホットキー", "押すたびにAdd/Removeモードを切り替えます。"), GUILayout.Width(95));
                var toggleStr = EditorGUILayout.TextField(_modeToggleHotkey.ToString(), GUILayout.Width(60));
                if (Enum.TryParse<KeyCode>(toggleStr, out var toggleParsed) && toggleParsed != _modeToggleHotkey)
                {
                    _modeToggleHotkey = toggleParsed;
                    EditorPrefs.SetInt(Pref_ModeToggleHotkey, (int)_modeToggleHotkey);
                }
            }

            // Scene overlay options
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("シーンオーバーレイ", EditorStyles.boldLabel);
            using (new EditorGUILayout.HorizontalScope())
            {
                int newUv = EditorGUILayout.Popup(new GUIContent("UVチャンネル", "解析・プレビューに使用するUV（UV0..UV7）。変更時に自動で再解析します。"), _uvChannel, Enumerable.Range(0, 8).Select(i => $"UV{i}").ToArray());
                if (newUv != _uvChannel)
                {
                    _uvChannel = newUv;
                    EditorPrefs.SetInt(Pref_UVChannel, _uvChannel);
                    AnalyzeTargetMesh();
                }
                GUILayout.FlexibleSpace();
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                bool onTop = EditorGUILayout.ToggleLeft(new GUIContent("最前面に描画 (X-Ray)", "常に手前にワイヤー/シームを表示します（Zテスト無効）。"), _overlayOnTop);
                if (onTop != _overlayOnTop)
                {
                    _overlayOnTop = onTop;
                    EditorPrefs.SetBool(Pref_OverlayOnTop, _overlayOnTop);
                    SceneView.RepaintAll();
                }
                GUILayout.FlexibleSpace();
            }
            using (new EditorGUILayout.HorizontalScope())
            {
                bool na = EditorGUILayout.ToggleLeft(new GUIContent("アンチエイリアスを無効化（高速）", "線をAAなし（1px）で一括描画します。太さ設定はAA有効時のみ反映されます。"), _disableAA);
                if (na != _disableAA)
                {
                    _disableAA = na;
                    EditorPrefs.SetBool(Pref_DisableAA, _disableAA);
                    SceneView.RepaintAll();
                }
                bool bfc = EditorGUILayout.ToggleLeft(new GUIContent("バックフェース抑制（選択表示）", "カメラに背を向ける三角形のワイヤーを描画しません（選択表示のみ）。"), _backfaceCull);
                if (bfc != _backfaceCull)
                {
                    _backfaceCull = bfc;
                    EditorPrefs.SetBool(Pref_BackfaceCull, _backfaceCull);
                    SceneView.RepaintAll();
                }
                GUILayout.FlexibleSpace();
            }

            // Advanced options foldout: Thickness & Depth Offset
            _showAdvancedOptionsFoldout = EditorGUILayout.Foldout(_showAdvancedOptionsFoldout, new GUIContent("詳細オプション", "詳細設定を開閉します。"), true);
            if (_showAdvancedOptionsFoldout)
            {
                using (new EditorGUI.IndentLevelScope())
                {
                    float th = EditorGUILayout.Slider(new GUIContent("太さ", "シーンビューに描画するラインの太さ。"), _overlaySeamThickness, 1f, 8f);
                    if (!Mathf.Approximately(th, _overlaySeamThickness))
                    {
                        _overlaySeamThickness = th;
                        EditorPrefs.SetFloat(Pref_OverlaySeamThickness, _overlaySeamThickness);
                        SceneView.RepaintAll();
                    }

                    // Depth Offset in mm (internally meters)
                    float pendingMm = _pendingOverlayDepthOffset * 1000f;
                    float newPendingMm = EditorGUILayout.Slider(new GUIContent("デプスオフセット (mm)", "ワイヤー/シームを法線方向へ前方オフセットして、面の重なりによるチラつきを回避します（単位: mm）。"), pendingMm, 0f, 20f);
                    if (!Mathf.Approximately(newPendingMm, pendingMm))
                    {
                        _pendingOverlayDepthOffset = Mathf.Clamp(newPendingMm, 0f, 20f) / 1000f; // store in meters
                    }

                    // Throttle commit to reduce heavy overlay rebuilds while dragging
                    double now = EditorApplication.timeSinceStartup;
                    bool mouseUp = Event.current.type == EventType.MouseUp;
                    bool timeToCommit = now >= _nextDepthCommitTime;
                    if ((timeToCommit || mouseUp) && !Mathf.Approximately(_pendingOverlayDepthOffset, _overlayDepthOffset))
                    {
                        _overlayDepthOffset = _pendingOverlayDepthOffset;
                        EditorPrefs.SetFloat(Pref_OverlayDepthOffset, _overlayDepthOffset);
                        // No heavy rebuild necessary: we draw using cached world pos/norm + offset in OnSceneGUI
                        SceneView.RepaintAll();
                        _nextDepthCommitTime = now + DepthCommitIntervalSec;
                    }

                    // (Depth Offset Distance Compensation omitted by request)
                }
            }
            EditorPrefs.SetBool(Pref_AdvancedOptionsFoldout, _showAdvancedOptionsFoldout);

            // Color options foldout
            _showColorOptionsFoldout = EditorGUILayout.Foldout(_showColorOptionsFoldout, new GUIContent("色オプション", "色の設定を開閉します。"), true);
            if (_showColorOptionsFoldout)
            {
                using (new EditorGUI.IndentLevelScope())
                {
                    var selCol = EditorGUILayout.ColorField(new GUIContent("Selected Islands", "シーンビューの選択ワイヤー色。"), _selectedSceneColor);
                    if (selCol != _selectedSceneColor)
                    {
                        _selectedSceneColor = selCol;
                        EditorPrefs.SetString(Pref_SelectedSceneColor, ColorUtility.ToHtmlStringRGBA(_selectedSceneColor));
                        SceneView.RepaintAll();
                    }
                    var seamCol = EditorGUILayout.ColorField(new GUIContent("シームの色", "シーンビューのシーム線の色。"), _seamColor);
                    if (seamCol != _seamColor)
                    {
                        _seamColor = seamCol;
                        EditorPrefs.SetString(Pref_SeamColor, ColorUtility.ToHtmlStringRGBA(_seamColor));
                        SceneView.RepaintAll();
                    }
                    var pfill = EditorGUILayout.ColorField(new GUIContent("プレビューの塗り色", "プレビュー上での選択領域の色（出力PNGは黒/白のまま）。"), _previewFillSelectedColor);
                    if (pfill != _previewFillSelectedColor)
                    {
                        _previewFillSelectedColor = pfill;
                        EditorPrefs.SetString(Pref_PreviewFillSelectedColor, ColorUtility.ToHtmlStringRGBA(_previewFillSelectedColor));
                        _previewDirty = true;
                        Repaint();
                    }
                    float a = EditorGUILayout.Slider(new GUIContent("塗りの透明度", "ベーステクスチャ上に重ねるときの塗りつぶしの透明度。"), _previewOverlayAlpha, 0f, 1f);
                    if (!Mathf.Approximately(a, _previewOverlayAlpha))
                    {
                        _previewOverlayAlpha = a;
                        EditorPrefs.SetFloat(Pref_PreviewOverlayAlpha, _previewOverlayAlpha);
                        _previewDirty = true;
                        Repaint();
                    }
                }
            }
            EditorPrefs.SetBool(Pref_ColorOptionsFoldout, _showColorOptionsFoldout);

            // Depth Offset moved under Advanced Options

            EditorGUILayout.Space();
            using (new EditorGUILayout.HorizontalScope())
            {
                if (GUILayout.Button(new GUIContent("Analyze UVs", "UVの島とシーム（UV切れ目）を解析します。"), GUILayout.Height(24)))
                {
                    AnalyzeTargetMesh();
                }
                if (GUILayout.Button(new GUIContent("Invert", "選択されていない島を選択し、選択済みを解除します。"), GUILayout.Height(24)))
                {
                    InvertSelection();
                }
                if (GUILayout.Button(new GUIContent("Select All", "全てのUVアイランドを選択します。"), GUILayout.Height(24)))
                {
                    SelectAll();
                }
                if (GUILayout.Button(new GUIContent("Clear", "選択をすべて解除します。"), GUILayout.Height(24)))
                {
                    ClearSelection();
                }
            }

            EditorGUILayout.Space();
            // プレビュー設定
            using (new EditorGUILayout.HorizontalScope())
            {
                var hasBase = GetBaseTexture() != null;
                using (new EditorGUI.DisabledScope(!hasBase))
                {
                    bool overlay = EditorGUILayout.ToggleLeft(new GUIContent("プレビューにベーステクスチャを重ねる", "対象のベーステクスチャの上に、選択マスクの半透明オーバーレイを表示します。"), _previewOverlayBaseTex);
                    if (overlay != _previewOverlayBaseTex)
                    {
                        _previewOverlayBaseTex = overlay;
                        EditorPrefs.SetBool(Pref_PreviewOverlayBaseTex, _previewOverlayBaseTex);
                        Repaint();
                    }
                }
                if (!hasBase) EditorGUILayout.LabelField("（ベーステクスチャなし）", GUILayout.Width(140));
            }
            using (new EditorGUILayout.HorizontalScope())
            {
                bool dbg = EditorGUILayout.ToggleLeft(new GUIContent("UVアイランド境界をプレビュー表示", "プレビュー上にUVアイランドの境界（シーム）を線で重ねて表示します。"), _showIslandPreview);
                if (dbg != _showIslandPreview)
                {
                    _showIslandPreview = dbg;
                    EditorPrefs.SetBool(Pref_ShowIslandPreview, _showIslandPreview);
                    Repaint();
                }
                bool inv = EditorGUILayout.ToggleLeft(new GUIContent("マスク反転（Union結果を反転）", "Unionで生成したマスク（黒＝塗り）を最終的に反転します。選択の反転とは独立しています。"), _invertMask);
                if (inv != _invertMask)
                {
                    _invertMask = inv;
                    EditorPrefs.SetBool(Pref_InvertMask, _invertMask);
                    _previewDirty = true;
                }
                GUILayout.FlexibleSpace();
            }
            DrawUVPreview();

            // UV dilation (pixel margin)
            EditorGUILayout.Space();
            using (new EditorGUILayout.HorizontalScope())
            {
                int newMargin = EditorGUILayout.IntSlider(new GUIContent("ピクセルマージン", "マスクの黒領域をピクセル単位で膨張させ、UVシーム付近のにじみを防ぎます。"), _pixelMargin, 0, 16);
                if (newMargin != _pixelMargin)
                {
                    _pixelMargin = newMargin;
                    EditorPrefs.SetInt(Pref_PixelMargin, _pixelMargin);
                    _previewDirty = true;
                }
            }

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("書き出し", EditorStyles.boldLabel);
            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.LabelField(new GUIContent("解像度", "プレビュー/書き出しのテクスチャ解像度。"), GUILayout.Width(100));
                int newSize = EditorGUILayout.IntPopup(_textureSize, new[] { "512", "1024", "2048", "4096" }, new[] { 512, 1024, 2048, 4096 }, GUILayout.Width(100));
                if (newSize != _textureSize)
                {
                    _textureSize = newSize;
                    _previewDirty = true;
                    EditorPrefs.SetInt(Pref_TextureSize, _textureSize);
                }

                _fileName = EditorGUILayout.TextField(new GUIContent("ファイル名", "出力PNGのファイル名（拡張子は自動付与）。"), _fileName);
            }
            // Channel-wise export (foldable)
            _showChannelWriteFoldout = EditorGUILayout.Foldout(_showChannelWriteFoldout, new GUIContent("チャンネル別書き込み", "RGBAの特定チャンネルにマスクを書き込みます。PNG/頂点カラーに対応。"), true);
            if (_showChannelWriteFoldout)
            {
                using (new EditorGUILayout.VerticalScope(EditorStyles.helpBox))
                {
                    bool ch = EditorGUILayout.ToggleLeft(new GUIContent("有効", "チャンネル別書き込みを有効にします。"), _channelWrite);
                    if (ch != _channelWrite) { _channelWrite = ch; EditorPrefs.SetBool(Pref_ChannelWrite, _channelWrite); }
                    using (new EditorGUI.DisabledScope(!_channelWrite))
                    {
                        var newBase = EditorGUILayout.ObjectField(new GUIContent("ベースPNG", "上書き先となるPNG。未指定の場合は新規PNGとして保存します。"), _basePNG, typeof(Texture2D), false) as Texture2D;
                        if (newBase != _basePNG)
                        {
                            _basePNG = newBase;
                            string path = _basePNG ? AssetDatabase.GetAssetPath(_basePNG) : string.Empty;
                            EditorPrefs.SetString(Pref_BasePNGAssetPath, path);
                        }
                        EditorGUILayout.LabelField("書き込みチャンネル");
                        using (new EditorGUILayout.HorizontalScope())
                        {
                            bool r = EditorGUILayout.ToggleLeft(new GUIContent("R", "赤チャンネルに書き込み"), _cwR, GUILayout.Width(40));
                            bool g = EditorGUILayout.ToggleLeft(new GUIContent("G", "緑チャンネルに書き込み"), _cwG, GUILayout.Width(40));
                            bool b = EditorGUILayout.ToggleLeft(new GUIContent("B", "青チャンネルに書き込み"), _cwB, GUILayout.Width(40));
                            bool a = EditorGUILayout.ToggleLeft(new GUIContent("A", "アルファに書き込み"), _cwA, GUILayout.Width(40));
                            if (r != _cwR) { _cwR = r; EditorPrefs.SetBool(Pref_ChannelWrite_R, _cwR); }
                            if (g != _cwG) { _cwG = g; EditorPrefs.SetBool(Pref_ChannelWrite_G, _cwG); }
                            if (b != _cwB) { _cwB = b; EditorPrefs.SetBool(Pref_ChannelWrite_B, _cwB); }
                            if (a != _cwA) { _cwA = a; EditorPrefs.SetBool(Pref_ChannelWrite_A, _cwA); }
                        }
                        // Base mesh for vertex color baking
                        var newBaseMesh = EditorGUILayout.ObjectField(new GUIContent("ベースメッシュ (頂点カラー)", "頂点カラーの上書きベースに使用するメッシュ。頂点数が一致する必要があります。"), _baseVCMesh, typeof(Mesh), false) as Mesh;
                        if (newBaseMesh != _baseVCMesh)
                        {
                            _baseVCMesh = newBaseMesh;
                            string meshPath = _baseVCMesh ? AssetDatabase.GetAssetPath(_baseVCMesh) : string.Empty;
                            EditorPrefs.SetString(Pref_BaseVCMeshAssetPath, meshPath);
                        }
                        EditorGUILayout.Space(4);
                        EditorGUILayout.LabelField("頂点カラー焼き込み", EditorStyles.boldLabel);
                        using (new EditorGUILayout.HorizontalScope())
                        {
                            if (GUILayout.Button(new GUIContent("頂点カラーに焼き込み", "選択マスクを頂点カラーにチャンネル別で焼き込み、新規メッシュを保存します。"), GUILayout.Height(24)))
                            {
                                BakeMaskToVertexColors_ChannelWise();
                            }
                        }
                        _overwriteExistingVC = EditorGUILayout.ToggleLeft(new GUIContent("同名ファイルを上書き", "同名のメッシュアセットが存在する場合に上書き保存します。無効時は連番で保存します。"), _overwriteExistingVC);
                    }
                }
            }
            EditorPrefs.SetBool(Pref_ChannelWriteFoldout, _showChannelWriteFoldout);
            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.LabelField(new GUIContent("出力フォルダ", "出力先フォルダ（Assets配下）。"), GUILayout.Width(90));
                EditorGUILayout.TextField(_outputDir);
                if (GUILayout.Button(new GUIContent("参照", "出力先フォルダを選択します（プロジェクトの Assets 以下）。"), GUILayout.Width(90)))
                {
                    var selected = EditorUtility.OpenFolderPanel("Assets 配下の出力フォルダを選択", _outputDir, "");
                    if (!string.IsNullOrEmpty(selected))
                    {
                        if (selected.Contains("Assets"))
                        {
                            // 絶対パスをプロジェクト相対に変換
                            var projPath = Path.GetFullPath(Application.dataPath + "/..");
                            var rel = MakeProjectRelative(selected, projPath);
                            if (!string.IsNullOrEmpty(rel))
                            {
                                _outputDir = rel.Replace('\\', '/');
                                EditorPrefs.SetString(Pref_LastSaveDir, _outputDir);
                            }
                        }
                        else
                        {
                            EditorUtility.DisplayDialog("無効なフォルダ", "プロジェクトの Assets 配下のフォルダを選択してください。", "OK");
                        }
                    }
                }
            }
            using (new EditorGUILayout.HorizontalScope())
            {
                GUILayout.FlexibleSpace();
                GUI.enabled = _analysis != null;
                if (GUILayout.Button(new GUIContent("PNGを保存", "現在の選択に基づくUVマスクをPNGとして保存します。ベースPNGが指定されている場合、選択チャンネルを上書き保存します。"), GUILayout.Height(28), GUILayout.Width(140)))
                {
                    SaveMaskPNG();
                }
                GUI.enabled = true;
            }

            EditorGUILayout.HelpBox(
                $"使い方:\n1) 対象を設定し 'Analyze UVs' を実行。\n2) 左クリックで現在のモード（Add/Remove）に従って選択を変更。\n3) ホットキー [{_modeToggleHotkey}] を押すたびにAdd/Removeがトグル。\n4) Invert / Select All / Clear を必要に応じて使用。\n5) Export の設定を行い Save PNG。",
                MessageType.Info);
            EditorGUILayout.EndScrollView();
        }

        private void HandleDragAndDrop(Rect dropRect)
        {
            var evt = Event.current;
            if (!dropRect.Contains(evt.mousePosition)) return;

            if (evt.type == EventType.DragUpdated || evt.type == EventType.DragPerform)
            {
                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                if (evt.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();
                    foreach (var obj in DragAndDrop.objectReferences)
                    {
                        if (obj is GameObject go)
                        {
                            SetTarget(go);
                            break;
                        }
                    }
                }
                evt.Use();
            }
        }

        private void SetTarget(GameObject go)
        {
            _targetGO = go;
            _targetRenderer = null;
            _targetMesh = null;
            _targetTransform = null;
            _analysis = null;
            _selectedIslands.Clear();
            _previewDirty = true;
            CleanupTempCollider();
            if (_bakedMesh != null)
            {
                try { DestroyImmediate(_bakedMesh); } catch { }
                _bakedMesh = null;
            }

            if (_targetGO == null) return;

            // Prefer SkinnedMeshRenderer, else MeshRenderer
            var smr = _targetGO.GetComponentInChildren<SkinnedMeshRenderer>();
            var mr = _targetGO.GetComponentInChildren<MeshRenderer>();
            if (smr != null)
            {
                _targetRenderer = smr;
                _targetMesh = smr.sharedMesh;
                _targetTransform = smr.transform;
            }
            else if (mr != null)
            {
                _targetRenderer = mr;
                var mf = mr.GetComponent<MeshFilter>();
                _targetMesh = mf ? mf.sharedMesh : null;
                _targetTransform = mr.transform;
            }

            if (_targetMesh == null)
                {
                    EditorUtility.DisplayDialog("メッシュが見つかりません", "選択したオブジェクトにはメッシュが含まれていません。", "OK");
                return;
            }

            Log($"[SetTarget] Target set to '{_targetGO.name}', Mesh='{_targetMesh.name}', VertexCount={_targetMesh.vertexCount}, TriCount={_targetMesh.triangles.Length/3}");
            // Default file name: <ObjectName>_mask
            _fileName = _targetGO.name + "_mask";
            // Auto-bake current pose for SkinnedMeshRenderer
            BakeCurrentPoseAuto();
            AnalyzeTargetMesh();
            EnsureTempCollider();
        }

        private void AnalyzeTargetMesh()
        {
            if (_targetMesh == null)
                {
                    EditorUtility.DisplayDialog("対象なし", "メッシュを持つ対象を設定してください。", "OK");
                return;
            }
            try
            {
                _analysis = UVAnalyzer.Analyze(_targetMesh, _uvChannel);
                _selectedIslands.Clear();
                _previewDirty = true;
                _labelMapDirty = true;
                _overlayCacheValid = false;
                // Auto-bake after analysis as well (keeps collider/overlay aligned to current pose)
                BakeCurrentPoseAuto();
                Repaint();
                Log($"[Analyze] Found {_analysis.Islands.Count} UV islands, {_analysis.BorderEdges.Count} UV border edges");
            }
            catch (Exception ex)
            {
                Debug.LogError($"UV analysis failed: {ex.Message}\n{ex}");
                Log($"[Analyze][Error] {ex}");
            }
        }

        private void InvertSelection()
        {
            if (_analysis == null) return;
            var newSel = new HashSet<int>();
            for (int i = 0; i < _analysis.Islands.Count; i++)
            {
                if (!_selectedIslands.Contains(i)) newSel.Add(i);
            }
            _selectedIslands = newSel;
            _previewDirty = true;
        }

        private void SelectAll()
        {
            if (_analysis == null) return;
            _selectedIslands = new HashSet<int>(Enumerable.Range(0, _analysis.Islands.Count));
            _previewDirty = true;
        }

        private void ClearSelection()
        {
            _selectedIslands.Clear();
            _previewDirty = true;
        }

        private void DrawUVPreview()
        {
            var rect = GUILayoutUtility.GetAspectRect(1f, GUILayout.ExpandWidth(true), GUILayout.ExpandHeight(true));
            EditorGUI.DrawRect(rect, UVFrame * 0.5f);

            if (_analysis == null)
            {
                GUI.Label(rect, "UVをプレビューするには解析を実行してください", new GUIStyle(EditorStyles.centeredGreyMiniLabel) { alignment = TextAnchor.MiddleCenter });
                return;
            }

            if (_previewTex == null || _previewTex.width != _textureSize)
            {
                if (_previewTex != null) DestroyImmediate(_previewTex);
                _previewTex = new Texture2D(_textureSize, _textureSize, TextureFormat.RGBA32, false, true)
                {
                    filterMode = FilterMode.Point,
                    wrapMode = TextureWrapMode.Clamp,
                    name = "UVMaskPreview"
                };
                _previewDirty = true;
                _labelMapDirty = true;
            }
            if (_previewOverlayTex == null || _previewOverlayTex.width != _textureSize)
            {
                if (_previewOverlayTex != null) DestroyImmediate(_previewOverlayTex);
                _previewOverlayTex = new Texture2D(_textureSize, _textureSize, TextureFormat.RGBA32, false, true)
                {
                    filterMode = FilterMode.Point,
                    wrapMode = TextureWrapMode.Clamp,
                    name = "UVMaskOverlay"
                };
                _previewDirty = true;
            }

            if (_previewDirty)
            {
                RegeneratePreviewTexture(_previewTex, _previewOverlayTex);
                _previewDirty = false;
            }

            if (Event.current.type == EventType.Repaint)
            {
                // draw texture fitting inside rect with padding
                var pad = 6f;
                var texRect = new Rect(rect.x + pad, rect.y + pad, rect.width - pad * 2, rect.height - pad * 2);
                // Ensure the actual drawn image area is a centered square to match the mask's aspect
                float side = Mathf.Min(texRect.width, texRect.height);
                var imgRect = new Rect(
                    texRect.x + (texRect.width - side) * 0.5f,
                    texRect.y + (texRect.height - side) * 0.5f,
                    side, side
                );
                var baseTex = _previewOverlayBaseTex ? GetBaseTexture() : null;
                if (baseTex != null)
                {
                    // Draw base texture first
                    GUI.DrawTexture(imgRect, baseTex, ScaleMode.ScaleToFit, true);
                    // Then draw semi-transparent overlay using alpha blend
                    if (_previewOverlayTex != null)
                    {
                        GUI.DrawTexture(imgRect, _previewOverlayTex, ScaleMode.ScaleToFit, true);
                    }
                }
                else
                {
                    // Default: mask alone (黒=選択, 白=非選択)
                    GUI.DrawTexture(imgRect, _previewTex, ScaleMode.ScaleToFit, true);
                }
                // Debug: UVアイランド境界（プレビュー四角にクリップ）
                if (_showIslandPreview && _analysis != null && _analysis.BorderEdges != null && _analysis.BorderEdges.Count > 0)
                {
                    GUI.BeginGroup(imgRect);
                    var localRect = new Rect(0, 0, imgRect.width, imgRect.height);
                    Handles.BeginGUI();
                    Handles.color = new Color(1f, 0.5f, 0f, 1f);
                    foreach (var be in _analysis.BorderEdges)
                    {
                        float ax = Mathf.Lerp(localRect.x, localRect.xMax, Mathf.Clamp01(be.uv0.x));
                        float ay = Mathf.Lerp(localRect.yMax, localRect.y, Mathf.Clamp01(be.uv0.y));
                        float bx = Mathf.Lerp(localRect.x, localRect.xMax, Mathf.Clamp01(be.uv1.x));
                        float by = Mathf.Lerp(localRect.yMax, localRect.y, Mathf.Clamp01(be.uv1.y));
                        Handles.DrawLine(new Vector3(ax, ay, 0), new Vector3(bx, by, 0));
                    }
                    Handles.EndGUI();
                    GUI.EndGroup();
                }
                // draw 0..1 frame
                Handles.color = UVFrame;
                Handles.DrawLine(new Vector3(imgRect.x, imgRect.y), new Vector3(imgRect.xMax, imgRect.y));
                Handles.DrawLine(new Vector3(imgRect.xMax, imgRect.y), new Vector3(imgRect.xMax, imgRect.yMax));
                Handles.DrawLine(new Vector3(imgRect.xMax, imgRect.yMax), new Vector3(imgRect.x, imgRect.yMax));
                Handles.DrawLine(new Vector3(imgRect.x, imgRect.yMax), new Vector3(imgRect.x, imgRect.y));
            }
        }

        private void ToggleAddRemoveMode(SceneView sv)
        {
            double now = EditorApplication.timeSinceStartup;
            if (now - _lastHotkeyToggleTime < 0.05f) return; // 連打による二重トグル防止
            _lastHotkeyToggleTime = now;
            _addMode = !_addMode;
            var targetSV = sv ?? SceneView.lastActiveSceneView;
            if (targetSV != null) targetSV.ShowNotification(new GUIContent(_addMode ? "Mode: Add" : "Mode: Remove"));
            Repaint();
            SceneView.RepaintAll();
        }

        private void RegeneratePreviewTexture(Texture2D tex, Texture2D overlay)
        {
            int count = tex.width * tex.height;
            var mask = new byte[count];
            // Union: 選択済みアイランドの全三角形をラスタライズして、少なくとも1つに覆われていれば255
            BuildUnionMask(tex.width, tex.height, mask);
            // マスク反転（選択の反転ではなく、Union結果の反転）
            if (_invertMask)
            {
                for (int i = 0; i < count; i++) mask[i] = (byte)(mask[i] == 0 ? 255 : 0);
            }
            if (_pixelMargin > 0)
            {
                if (_invertMask) UVMaskExport.DilateWhiteBytes(mask, tex.width, tex.height, _pixelMargin);
                else DilateMaskBytes(mask, tex.width, tex.height, _pixelMargin);
            }
            var pixels32 = new Color32[count];
            var selCol32 = (Color32)_previewFillSelectedColor;
            var unselCol32 = (Color32)IslandFillUnselected;
            for (int i = 0; i < count; i++) pixels32[i] = mask[i] != 0 ? selCol32 : unselCol32;
            tex.SetPixels32(pixels32);
            tex.Apply(false, false);

            if (overlay != null)
            {
                var ov = new Color32[count];
                byte a = (byte)Mathf.Clamp(Mathf.RoundToInt(_previewOverlayAlpha * 255f), 0, 255);
                var col = (Color32)_previewFillSelectedColor; // 選択色のRGBを使用
                col.a = a; // 透明度はスライダーの値
                var zero = new Color32(0, 0, 0, 0); // 非選択は透明
                for (int i = 0; i < count; i++) ov[i] = mask[i] != 0 ? col : zero;
                overlay.SetPixels32(ov);
                overlay.Apply(false, false);
            }
        }

        private Texture GetBaseTexture()
        {
            if (_targetRenderer == null) return null;
            var mats = _targetRenderer.sharedMaterials;
            if (mats == null) return null;
            foreach (var m in mats)
            {
                if (m == null) continue;
                // よくあるプロパティ名をチェック
                if (m.HasProperty("_BaseMap")) { var t = m.GetTexture("_BaseMap"); if (t != null) return t; }
                if (m.HasProperty("_MainTex")) { var t = m.GetTexture("_MainTex"); if (t != null) return t; }
            }
            return null;
        }

        private static void RasterizeTriangle(Texture2D tex, Color[] pixels, Vector2 uv0, Vector2 uv1, Vector2 uv2, Color color)
        {
            // Convert uv (0..1) to pixel coords
            int W = tex.width, H = tex.height;
            Vector2 p0 = new Vector2(Mathf.Clamp01(uv0.x) * (W - 1), Mathf.Clamp01(uv0.y) * (H - 1));
            Vector2 p1 = new Vector2(Mathf.Clamp01(uv1.x) * (W - 1), Mathf.Clamp01(uv1.y) * (H - 1));
            Vector2 p2 = new Vector2(Mathf.Clamp01(uv2.x) * (W - 1), Mathf.Clamp01(uv2.y) * (H - 1));

            // Bounding box
            int minX = Mathf.Max(0, Mathf.FloorToInt(Mathf.Min(p0.x, Mathf.Min(p1.x, p2.x))));
            int maxX = Mathf.Min(W - 1, Mathf.CeilToInt(Mathf.Max(p0.x, Mathf.Max(p1.x, p2.x))));
            int minY = Mathf.Max(0, Mathf.FloorToInt(Mathf.Min(p0.y, Mathf.Min(p1.y, p2.y))));
            int maxY = Mathf.Min(H - 1, Mathf.CeilToInt(Mathf.Max(p0.y, Mathf.Max(p1.y, p2.y))));

            float Edge(Vector2 a, Vector2 b, Vector2 c)
            {
                return (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
            }

            float area = Edge(p0, p1, p2);
            if (Mathf.Approximately(area, 0)) return;

            for (int y = minY; y <= maxY; y++)
            {
                for (int x = minX; x <= maxX; x++)
                {
                    Vector2 p = new Vector2(x + 0.5f, y + 0.5f);
                    float w0 = Edge(p1, p2, p);
                    float w1 = Edge(p2, p0, p);
                    float w2 = Edge(p0, p1, p);
                    bool inside = (w0 >= 0 && w1 >= 0 && w2 >= 0) || (w0 <= 0 && w1 <= 0 && w2 <= 0);
                    if (!inside) continue;

                    int idx = y * W + x;
                    pixels[idx] = color;
                }
            }
        }

        private void BuildLabelMap(int width, int height)
        {
            _labelMap = UVMaskExport.BuildLabelMapTransient(_analysis, width, height);
            _labelMapSize = _labelMap.Length;
            _labelMapDirty = false;
        }

        // Build a temporary label map for a given resolution (used for export)
    private int[] BuildLabelMapTransient(int width, int height) => UVMaskExport.BuildLabelMapTransient(_analysis, width, height);

        private static void RasterizeTriangleLabel(int W, int H, int[] labels, int islandIdx, Vector2 uv0, Vector2 uv1, Vector2 uv2)
        {
            Vector2 p0 = new Vector2(Mathf.Clamp01(uv0.x) * (W - 1), Mathf.Clamp01(uv0.y) * (H - 1));
            Vector2 p1 = new Vector2(Mathf.Clamp01(uv1.x) * (W - 1), Mathf.Clamp01(uv1.y) * (H - 1));
            Vector2 p2 = new Vector2(Mathf.Clamp01(uv2.x) * (W - 1), Mathf.Clamp01(uv2.y) * (H - 1));

            int minX = Mathf.Max(0, Mathf.FloorToInt(Mathf.Min(p0.x, Mathf.Min(p1.x, p2.x))));
            int maxX = Mathf.Min(W - 1, Mathf.CeilToInt(Mathf.Max(p0.x, Mathf.Max(p1.x, p2.x))));
            int minY = Mathf.Max(0, Mathf.FloorToInt(Mathf.Min(p0.y, Mathf.Min(p1.y, p2.y))));
            int maxY = Mathf.Min(H - 1, Mathf.CeilToInt(Mathf.Max(p0.y, Mathf.Max(p1.y, p2.y))));

            float Edge(Vector2 a, Vector2 b, Vector2 c) => (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
            float area = Edge(p0, p1, p2);
            if (Mathf.Approximately(area, 0)) return;

            for (int y = minY; y <= maxY; y++)
            {
                for (int x = minX; x <= maxX; x++)
                {
                    Vector2 p = new Vector2(x + 0.5f, y + 0.5f);
                    float w0 = Edge(p1, p2, p);
                    float w1 = Edge(p2, p0, p);
                    float w2 = Edge(p0, p1, p);
                    bool inside = (w0 >= 0 && w1 >= 0 && w2 >= 0) || (w0 <= 0 && w1 <= 0 && w2 <= 0);
                    if (!inside) continue;
                    int idx = y * W + x;
                    labels[idx] = islandIdx;
                }
            }
        }

        // Morphological dilation to grow black (selected) areas by N pixels.
        private static void DilateMask(Color[] pixels, int width, int height, int iterations)
        {
            if (pixels == null || width <= 0 || height <= 0 || iterations <= 0) return;

            bool IsBlack(Color c) => (c.r + c.g + c.b) <= 1.0f; // treat dark colors as selected (black)

            Color[] src = pixels;
            for (int it = 0; it < iterations; it++)
            {
                var dst = new Color[src.Length];
                Array.Copy(src, dst, src.Length);

                for (int y = 0; y < height; y++)
                {
                    int yOff = y * width;
                    for (int x = 0; x < width; x++)
                    {
                        int idx = yOff + x;
                        if (IsBlack(src[idx])) { dst[idx] = Color.black; continue; }

                        bool neighborBlack = false;
                        for (int ny = y - 1; ny <= y + 1 && !neighborBlack; ny++)
                        {
                            if ((uint)ny >= (uint)height) continue;
                            int nyOff = ny * width;
                            for (int nx = x - 1; nx <= x + 1; nx++)
                            {
                                if ((uint)nx >= (uint)width) continue;
                                if (nx == x && ny == y) continue;
                                if (IsBlack(src[nyOff + nx])) { neighborBlack = true; break; }
                            }
                        }
                        if (neighborBlack) dst[idx] = Color.black;
                    }
                }

                src = dst; // next iteration reads from freshly dilated buffer
            }

            // Write back into original buffer
            if (!ReferenceEquals(src, pixels)) Array.Copy(src, 0, pixels, 0, pixels.Length);
        }

    private static void DilateMaskBytes(byte[] mask, int width, int height, int iterations) => UVMaskExport.DilateMaskBytes(mask, width, height, iterations);

        // 選択済みアイランドのUnionをピクセルマスクに構築
        private void BuildUnionMask(int width, int height, byte[] dst)
        {
            Array.Clear(dst, 0, dst.Length);
            if (_analysis == null || _selectedIslands == null || _selectedIslands.Count == 0) return;
            foreach (var idx in _selectedIslands)
            {
                if (idx < 0 || idx >= _analysis.Islands.Count) continue;
                var isl = _analysis.Islands[idx];
                foreach (var tri in isl.Triangles)
                {
                    RasterizeTriangleToMask(width, height, dst, tri.uv0, tri.uv1, tri.uv2);
                }
            }
        }

        // UV三角形を0..1→ピクセル座標に変換してdstへ塗る（255）
        private static void RasterizeTriangleToMask(int W, int H, byte[] dst, Vector2 uv0, Vector2 uv1, Vector2 uv2)
        {
            Vector2 p0 = new Vector2(Mathf.Clamp01(uv0.x) * (W - 1), Mathf.Clamp01(uv0.y) * (H - 1));
            Vector2 p1 = new Vector2(Mathf.Clamp01(uv1.x) * (W - 1), Mathf.Clamp01(uv1.y) * (H - 1));
            Vector2 p2 = new Vector2(Mathf.Clamp01(uv2.x) * (W - 1), Mathf.Clamp01(uv2.y) * (H - 1));

            int minX = Mathf.Max(0, Mathf.FloorToInt(Mathf.Min(p0.x, Mathf.Min(p1.x, p2.x))));
            int maxX = Mathf.Min(W - 1, Mathf.CeilToInt(Mathf.Max(p0.x, Mathf.Max(p1.x, p2.x))));
            int minY = Mathf.Max(0, Mathf.FloorToInt(Mathf.Min(p0.y, Mathf.Min(p1.y, p2.y))));
            int maxY = Mathf.Min(H - 1, Mathf.CeilToInt(Mathf.Max(p0.y, Mathf.Max(p1.y, p2.y))));

            float Edge(Vector2 a, Vector2 b, Vector2 c) => (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
            float area = Edge(p0, p1, p2);
            if (Mathf.Approximately(area, 0)) return;
            bool topLeftRule = area > 0; // 一貫したルールで境界ピクセルの穴を減らす（任意）

            for (int y = minY; y <= maxY; y++)
            {
                for (int x = minX; x <= maxX; x++)
                {
                    Vector2 p = new Vector2(x + 0.5f, y + 0.5f);
                    float w0 = Edge(p1, p2, p);
                    float w1 = Edge(p2, p0, p);
                    float w2 = Edge(p0, p1, p);
                    bool inside = (w0 >= 0 && w1 >= 0 && w2 >= 0) || (w0 <= 0 && w1 <= 0 && w2 <= 0);
                    if (!inside)
                    {
                        // Top-left ruleで境界の隙を抑制（必要に応じて）
                        if (topLeftRule)
                        {
                            inside = (w0 == 0 && ((p2.y > p1.y) || (p2.y == p1.y && p2.x < p1.x))) ||
                                     (w1 == 0 && ((p0.y > p2.y) || (p0.y == p2.y && p0.x < p2.x))) ||
                                     (w2 == 0 && ((p1.y > p0.y) || (p1.y == p0.y && p1.x < p0.x)));
                        }
                    }
                    if (!inside) continue;
                    int idx = y * W + x;
                    dst[idx] = 255;
                }
            }
        }

        private void SaveMaskPNG()
        {
            if (_analysis == null)
            {
                EditorUtility.DisplayDialog("No Data", "Analyze a mesh first.", "OK");
                return;
            }

            // Ensure output dir exists
            if (!AssetDatabase.IsValidFolder(_outputDir)) { UVMaskExport.EnsureAssetFolderPath(_outputDir); }

            string path = EditorUtility.SaveFilePanelInProject("UVマスクを保存", _fileName, "png", "UVマスクの保存先を選択してください", _outputDir);
            if (string.IsNullOrEmpty(path)) return;

            int size = Mathf.Clamp(_textureSize, 8, 8192);
            var mask = new byte[size * size];
            BuildUnionMask(size, size, mask);
            if (_invertMask) { for (int i = 0; i < mask.Length; i++) mask[i] = (byte)(mask[i] == 0 ? 255 : 0); }
            if (_pixelMargin > 0)
            {
                if (_invertMask) UVMaskExport.DilateWhiteBytes(mask, size, size, _pixelMargin);
                else DilateMaskBytes(mask, size, size, _pixelMargin);
            }

            // If channel-wise writing is disabled, export classic B/W
            if (!_channelWrite)
            {
                var pixels32 = new Color32[mask.Length];
                for (int i = 0; i < mask.Length; i++) pixels32[i] = mask[i] != 0 ? new Color32(0, 0, 0, 255) : new Color32(255, 255, 255, 255);
                UVMaskExport.WritePngAtPath(path, pixels32, size);
                Log($"[Save] Wrote PNG {path} size={size}x{size}");
                RevealSaved(path);
                return;
            }

            // Channel-wise write path
            // Load base pixels or initialize white
            Color32[] basePixels;
            bool hasBase = _basePNG != null;
            if (hasBase)
            {
                string basePath = AssetDatabase.GetAssetPath(_basePNG);
                var baseTex = AssetDatabase.LoadAssetAtPath<Texture2D>(basePath);
                basePixels = UVMaskExport.LoadBasePixelsOrWhite(baseTex, size);
            }
            else { basePixels = Enumerable.Repeat(new Color32(255, 255, 255, 255), size * size).ToArray(); }

            // Compose mask into chosen channels
            for (int i = 0; i < basePixels.Length; i++)
            {
                bool selected = mask[i] != 0;
                byte v = (byte)(selected ? 0 : 255); // for RGB: selected=black
                var c = basePixels[i];
                if (hasBase)
                {
                    // Only overwrite selected pixels; keep others as-is
                    if (selected)
                    {
                        if (_cwR) c.r = v;
                        if (_cwG) c.g = v;
                        if (_cwB) c.b = v;
                        if (_cwA) c.a = 255;
                    }
                }
                else
                {
                    // No base: write full channel from mask
                    if (_cwR) c.r = v;
                    if (_cwG) c.g = v;
                    if (_cwB) c.b = v;
                    if (_cwA) c.a = (byte)(mask[i]); // 255 selected, 0 unselected
                }
                basePixels[i] = c;
            }

            UVMaskExport.WritePngAtPath(path, basePixels, size);
            Log($"[Save] Wrote PNG (channel-wise) {path} size={size}x{size}");
            RevealSaved(path);
        }

        private void OnSceneGUI(SceneView sv)
        {
            // Toggle hotkey: press to switch Add/Remove mode
            var e = Event.current;
            if (e.type == EventType.KeyDown && e.keyCode == _modeToggleHotkey && !EditorGUIUtility.editingTextField)
            {
                ToggleAddRemoveMode(sv);
                e.Use();
            }

            // Draw seams overlay
            if (_analysis != null && _targetTransform != null)
            {
                Handles.zTest = _overlayOnTop ? UnityEngine.Rendering.CompareFunction.Always : UnityEngine.Rendering.CompareFunction.LessEqual;
                EnsureWorldCache();
                Handles.color = _seamColor;
                // Draw seams: AA無効なら一括描画、AA有効なら従来の太線
                if (_analysis.BorderEdges != null)
                {
                    if (_disableAA)
                    {
                        var seamVerts = ListPool<Vector3>.Get();
                        foreach (var be in _analysis.BorderEdges)
                        {
                            if (_worldPosBase == null || _worldNormal == null) break;
                            if ((uint)be.v0 >= _worldPosBase.Length || (uint)be.v1 >= _worldPosBase.Length) continue;
                            var a = _worldPosBase[be.v0] + _worldNormal[be.v0] * _overlayDepthOffset;
                            var b = _worldPosBase[be.v1] + _worldNormal[be.v1] * _overlayDepthOffset;
                            seamVerts.Add(a); seamVerts.Add(b);
                        }
                        if (seamVerts.Count >= 2) Handles.DrawLines(seamVerts.ToArray());
                        ListPool<Vector3>.Release(seamVerts);
                    }
                    else
                    {
                        foreach (var be in _analysis.BorderEdges)
                        {
                            if (_worldPosBase == null || _worldNormal == null) break;
                            if ((uint)be.v0 >= _worldPosBase.Length || (uint)be.v1 >= _worldPosBase.Length) continue;
                            var a = _worldPosBase[be.v0] + _worldNormal[be.v0] * _overlayDepthOffset;
                            var b = _worldPosBase[be.v1] + _worldNormal[be.v1] * _overlayDepthOffset;
                            Handles.DrawAAPolyLine(_overlaySeamThickness, a, b);
                        }
                    }
                }

                // Draw selected islands overlay in scene if enabled
                if (_showSelectedInScene && _selectedIslands.Count > 0)
                {
                    Handles.color = _selectedSceneColor;
                    // 距離に応じて太さを減衰（遠くなるほど細く見える）
                    float thicknessBase = Mathf.Max(0.5f, _overlaySeamThickness);
                    float distForScale = 1f;
                    if (SceneView.lastActiveSceneView != null && SceneView.lastActiveSceneView.camera != null)
                    {
                        var cam = SceneView.lastActiveSceneView.camera;
                        var bounds = _targetRenderer != null ? _targetRenderer.bounds : new Bounds(_targetTransform.position, Vector3.one);
                        distForScale = Mathf.Max(0.1f, Vector3.Distance(cam.transform.position, bounds.center));
                    }
                    float thickness = Mathf.Clamp(thicknessBase / distForScale, 0.5f, thicknessBase);

                    if (_disableAA)
                    {
                        var lineVerts = ListPool<Vector3>.Get();
                        Camera cam = sv != null ? sv.camera : (SceneView.lastActiveSceneView ? SceneView.lastActiveSceneView.camera : null);
                        Vector3 camPos = cam ? cam.transform.position : Vector3.zero;
                        foreach (var idx in _selectedIslands)
                        {
                            if (idx < 0 || idx >= _analysis.Islands.Count) continue;
                            var isl = _analysis.Islands[idx];
                            foreach (var tri in isl.Triangles)
                            {
                                if (_worldPosBase == null || _worldNormal == null) break;
                                if ((uint)tri.v0 >= _worldPosBase.Length || (uint)tri.v1 >= _worldPosBase.Length || (uint)tri.v2 >= _worldPosBase.Length) continue;
                                var a = _worldPosBase[tri.v0] + _worldNormal[tri.v0] * _overlayDepthOffset;
                                var b = _worldPosBase[tri.v1] + _worldNormal[tri.v1] * _overlayDepthOffset;
                                var c = _worldPosBase[tri.v2] + _worldNormal[tri.v2] * _overlayDepthOffset;
                                if (_backfaceCull && cam)
                                {
                                    var n = Vector3.Cross(b - a, c - a);
                                    if (n.sqrMagnitude > 1e-12f)
                                    {
                                        // front-facing if dot(normal, camPos - center) > 0
                                        var center = (a + b + c) / 3f;
                                        if (Vector3.Dot(n.normalized, camPos - center) <= 0f) continue;
                                    }
                                }
                                lineVerts.Add(a); lineVerts.Add(b);
                                lineVerts.Add(b); lineVerts.Add(c);
                                lineVerts.Add(c); lineVerts.Add(a);
                            }
                        }
                        if (lineVerts.Count >= 2) Handles.DrawLines(lineVerts.ToArray());
                        ListPool<Vector3>.Release(lineVerts);
                    }
                    else
                    {
                        foreach (var idx in _selectedIslands)
                        {
                            if (idx < 0 || idx >= _analysis.Islands.Count) continue;
                            var isl = _analysis.Islands[idx];
                            foreach (var tri in isl.Triangles)
                            {
                                if (_worldPosBase == null || _worldNormal == null) break;
                                if ((uint)tri.v0 >= _worldPosBase.Length || (uint)tri.v1 >= _worldPosBase.Length || (uint)tri.v2 >= _worldPosBase.Length) continue;
                                float baseOffset = _overlayDepthOffset;
                                var a = _worldPosBase[tri.v0] + _worldNormal[tri.v0] * baseOffset;
                                var b = _worldPosBase[tri.v1] + _worldNormal[tri.v1] * baseOffset;
                                var c = _worldPosBase[tri.v2] + _worldNormal[tri.v2] * baseOffset;
                                if (_backfaceCull)
                                {
                                    Camera cam = sv != null ? sv.camera : (SceneView.lastActiveSceneView ? SceneView.lastActiveSceneView.camera : null);
                                    if (cam)
                                    {
                                        var n = Vector3.Cross(b - a, c - a);
                                        if (n.sqrMagnitude > 1e-12f)
                                        {
                                            var center = (a + b + c) / 3f;
                                            if (Vector3.Dot(n.normalized, cam.transform.position - center) <= 0f) continue;
                                        }
                                    }
                                }
                                // 各辺を個別に描画して、角でのミタージョイン延長による「飛び出し」を防止
                                Handles.DrawAAPolyLine(thickness, a, b);
                                Handles.DrawAAPolyLine(thickness, b, c);
                                Handles.DrawAAPolyLine(thickness, c, a);
                            }
                        }
                    }
                }
            }

            // Picking
            if (_analysis != null && e.type == EventType.MouseDown && e.button == 0)
            {
                // Click follows current mode; hotkey toggles the mode.
                TryPickAndToggleIsland(sv, e.mousePosition, _addMode);
                e.Use();
            }
        }

        private bool _overwriteExistingVC = false;

        private void BakeMaskToVertexColors()
        {
            if (_targetMesh == null || _analysis == null)
            {
                EditorUtility.DisplayDialog("対象なし", "メッシュ解析後に実行してください。", "OK");
                return;
            }
            try
            {
                var colors = UVVertexColorBaker.BuildVertexColors(_analysis, _selectedIslands, _targetMesh.vertexCount);
                var colored = UVVertexColorBaker.CreateColoredMesh(_targetMesh, colors);
                var folder = UVVertexColorBaker.GetDefaultBakeFolderForMesh(_targetMesh);
                var nameNoExt = _targetMesh.name + "_WithVertexColors";
                var assetPath = UVVertexColorBaker.SaveMeshAsset(colored, folder, nameNoExt, _overwriteExistingVC);
                Log($"[BakeVC] Saved mesh with vertex colors: {assetPath}");
                var obj = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(assetPath);
                if (obj != null) { ProjectWindowUtil.ShowCreatedAsset(obj); EditorGUIUtility.PingObject(obj); Selection.activeObject = obj; }
            }
            catch (Exception ex)
            {
                Debug.LogError($"Bake vertex colors failed: {ex.Message}\n{ex}");
                EditorUtility.DisplayDialog("エラー", "頂点カラーの焼き込みに失敗しました。Console を確認してください。", "OK");
            }
        }

        private void BakeMaskToVertexColors_ChannelWise()
        {
            if (_targetMesh == null || _analysis == null)
            {
                EditorUtility.DisplayDialog("対象なし", "メッシュ解析後に実行してください。", "OK");
                return;
            }
            try
            {
                // Determine base colors: prefer user-specified base mesh if valid
                Color32[] baseColors = null;
                if (_baseVCMesh != null)
                {
                    if (_baseVCMesh.vertexCount != _targetMesh.vertexCount)
                    {
                        EditorUtility.DisplayDialog("頂点数が一致しません", "ベースメッシュの頂点数が対象メッシュと一致しません。対象メッシュの頂点カラーをベースとして使用します。", "OK");
                        baseColors = _targetMesh.colors32;
                    }
                    else
                    {
                        baseColors = _baseVCMesh.colors32;
                    }
                }
                else
                {
                    baseColors = _targetMesh.colors32; // may be empty
                }
                var colors = UVVertexColorBaker.BuildVertexColorsChannelWise(
                    _analysis, _selectedIslands, _targetMesh.vertexCount, baseColors, _cwR, _cwG, _cwB, _cwA);
                var colored = UVVertexColorBaker.CreateColoredMesh(_targetMesh, colors);
                var folder = UVVertexColorBaker.GetDefaultBakeFolderForMesh(_targetMesh);
                var nameNoExt = _targetMesh.name + "_WithVertexColors";
                var assetPath = UVVertexColorBaker.SaveMeshAsset(colored, folder, nameNoExt, _overwriteExistingVC);
                Log($"[BakeVC-CH] Saved mesh with vertex colors: {assetPath}");
                var obj = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(assetPath);
                if (obj != null) { ProjectWindowUtil.ShowCreatedAsset(obj); EditorGUIUtility.PingObject(obj); Selection.activeObject = obj; }
            }
            catch (Exception ex)
            {
                Debug.LogError($"Bake vertex colors (channel-wise) failed: {ex.Message}\n{ex}");
                EditorUtility.DisplayDialog("エラー", "頂点カラーのチャンネル別焼き込みに失敗しました。Console を確認してください。", "OK");
            }
        }

        private void EnsureWorldCache()
        {
            if (_targetTransform == null || _analysis == null) return;
            var l2w = _targetTransform.localToWorldMatrix;
            var mesh = (_useBakedMesh && _bakedMesh != null) ? _bakedMesh : null;
            bool needRebuild = !_overlayCacheValid || _worldPosBase == null || _worldNormal == null || _lastLocalToWorld != l2w;
            if (mesh != null)
            {
                if (_worldPosBase == null || _worldPosBase.Length != mesh.vertexCount) needRebuild = true;
            }
            else
            {
                if (_worldPosBase == null || _worldPosBase.Length != _analysis.Vertices.Count) needRebuild = true;
            }
            if (!needRebuild) return;

            // Build world-space base positions and normals
            int vCount = mesh != null ? mesh.vertexCount : _analysis.Vertices.Count;
            if (_worldPosBase == null || _worldPosBase.Length != vCount) _worldPosBase = new Vector3[vCount];
            if (_worldNormal == null || _worldNormal.Length != vCount) _worldNormal = new Vector3[vCount];

            if (mesh != null)
            {
                var verts = mesh.vertices;
                var norms = mesh.normals;
                for (int i = 0; i < vCount; i++)
                {
                    var lp = (i < verts.Length) ? verts[i] : Vector3.zero;
                    var ln = (norms != null && i < norms.Length) ? norms[i] : Vector3.up;
                    if (ln.sqrMagnitude < 1e-8f) ln = Vector3.up;
                    _worldPosBase[i] = _targetTransform.TransformPoint(lp);
                    _worldNormal[i] = _targetTransform.TransformDirection(ln).normalized;
                }
            }
            else
            {
                for (int i = 0; i < vCount; i++)
                {
                    var lp = _analysis.Vertices[i];
                    var ln = (i < _analysis.Normals.Count) ? _analysis.Normals[i] : Vector3.up;
                    if (ln.sqrMagnitude < 1e-8f) ln = Vector3.up;
                    _worldPosBase[i] = _targetTransform.TransformPoint(lp);
                    _worldNormal[i] = _targetTransform.TransformDirection(ln).normalized;
                }
            }

            _lastLocalToWorld = l2w;
            _overlayCacheValid = true;
        }

    private void TryPickAndToggleIsland(SceneView sv, Vector2 guiPos, bool add)
        {
            if (_targetGO == null || _targetMesh == null) return;
            EnsureTempCollider();
            if (_tempCollider == null) return;

            Ray ray = HandleUtility.GUIPointToWorldRay(guiPos);
            if (Physics.Raycast(ray, out var hit, Mathf.Infinity))
            {
                if (hit.collider != _tempCollider) return;
                int triIndex = hit.triangleIndex; // triangle in mesh space
                if (!_analysis.TriangleToIsland.TryGetValue(triIndex, out int islandIdx)) return;

                bool wasSelected = _selectedIslands.Contains(islandIdx);
                if (add) _selectedIslands.Add(islandIdx); else _selectedIslands.Remove(islandIdx);
                _previewDirty = true;
                Repaint();
                sv.Repaint();
                Log($"[Pick] tri={triIndex} island={islandIdx} {( add ? "ADD" : "REMOVE")} (wasSelected={wasSelected})");
            }
        }

        private void EnsureTempCollider()
        {
            // We create a temporary MeshCollider to get triangleIndex via Physics.Raycast.
            // For SkinnedMeshRenderer we use its sharedMesh in the current bind pose.
            if (_targetGO == null || _targetMesh == null) { CleanupTempCollider(); return; }
            if (_tempCollider != null) return;

            _tempColliderGO = new GameObject("__UVMaskPickerCollider__");
            _tempColliderGO.hideFlags = HideFlags.HideAndDontSave;
            _tempColliderGO.transform.SetPositionAndRotation(_targetTransform.position, _targetTransform.rotation);
            _tempColliderGO.transform.localScale = _targetTransform.lossyScale; // approximate

            _tempCollider = _tempColliderGO.AddComponent<MeshCollider>();
            _tempCollider.sharedMesh = (_useBakedMesh && _bakedMesh != null) ? _bakedMesh : _targetMesh;
            _tempCollider.convex = false;
            Log("[Collider] Created temporary MeshCollider for picking");
        }

        private void BakeCurrentPose()
        {
            if (!(_targetRenderer is SkinnedMeshRenderer smr))
            {
                EditorUtility.DisplayDialog("Bake", "Bake is only available for SkinnedMeshRenderer.", "OK");
                return;
            }
            if (_bakedMesh == null) _bakedMesh = new Mesh { name = $"{_targetMesh?.name}_Baked" };
            else _bakedMesh.Clear();
            try
            {
                smr.BakeMesh(_bakedMesh);
                _overlayCacheValid = false;
                if (_tempCollider != null) _tempCollider.sharedMesh = _useBakedMesh ? _bakedMesh : _targetMesh;
                SceneView.RepaintAll();
                Log($"[Bake] Baked pose to Mesh verts={_bakedMesh.vertexCount} tris={_bakedMesh.triangles.Length/3}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"Bake failed: {ex.Message}\n{ex}");
                Log($"[Bake][Error] {ex}");
            }
        }

        // Silent auto-bake for SkinnedMeshRenderer; no dialogs
        private void BakeCurrentPoseAuto()
        {
            if (!(_targetRenderer is SkinnedMeshRenderer smr)) return;
            if (_bakedMesh == null) _bakedMesh = new Mesh { name = $"{_targetMesh?.name}_Baked" };
            else _bakedMesh.Clear();
            try
            {
                smr.BakeMesh(_bakedMesh);
                _overlayCacheValid = false;
                if (_tempCollider != null) _tempCollider.sharedMesh = _useBakedMesh ? _bakedMesh : _targetMesh;
            }
            catch (Exception) { /* ignore in auto mode */ }
        }

        private void CleanupTempCollider()
        {
            if (_tempColliderGO != null)
            {
                try
                {
                    DestroyImmediate(_tempColliderGO);
                    Log("[Collider] Cleaned up temporary MeshCollider");
                }
                catch { /* ignore */ }
                _tempColliderGO = null;
                _tempCollider = null;
            }
        }

        private static string MakeProjectRelative(string absPath, string projectRoot)
        {
            try
            {
                var full = Path.GetFullPath(absPath).TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
                var root = Path.GetFullPath(projectRoot).TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
                if (!full.StartsWith(root, StringComparison.OrdinalIgnoreCase)) return null;
                var rel = full.Substring(root.Length + 1);
                return rel;
            }
            catch { return null; }
        }

        private static void EnsureAssetFolderPath(string assetFolderPath) => UVMaskExport.EnsureAssetFolderPath(assetFolderPath);

        private static void RevealSaved(string path)
        {
            var obj = AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(path);
            if (obj != null) { ProjectWindowUtil.ShowCreatedAsset(obj); EditorGUIUtility.PingObject(obj); Selection.activeObject = obj; }
        }

        private static void Log(string msg)
        {
            try
            {
                Directory.CreateDirectory(LogDir);
                File.AppendAllText(LogPath, $"{DateTime.Now:HH:mm:ss} {msg}\n");
            }
            catch { /* ignore */ }
            Debug.Log($"[UVMaskMaker] {msg}");
        }
    }

    
}
